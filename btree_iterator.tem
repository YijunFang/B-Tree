template <typename T> typename btree_iterator<T>::reference 
btree_iterator<T>::operator*() const {
	return pointee_->elem_[index_];
}

template<typename T> bool
btree_iterator<T>::operator ==(const btree_iterator<T>& other) const {
	return (btree_ == other.btree_ 
		&& pointee_ == other.pointee_ 
		&& index_ == other.index_);
}

template<typename T> btree_iterator<T>&
btree_iterator<T>::operator ++() {
	if(pointee_ == nullptr){
		pointee_ = btree_->_head;
		index_ = 0;
	} else if(pointee_->children_[index_+1] != nullptr){
		pointee_ = pointee_->children_[index_+1];
		index_ = 0;
		moveDown();
	} else if(index_ < pointee_->usedSpace_-1){
		index_++;
	} else
		moveUp(currElement());
		
		return *this;
}

template<typename T> btree_iterator<T>&
btree_iterator<T>::operator --(){
	if(pointee_ == nullptr){
		pointee_ = btree_->_tail;
		index_ = pointee_->usedSpace_-1;//the last element
	}else if (pointee_->children_[index_] != nu)
}


template<typename T> void
btree_iterator<T>::moveUp(value_type element ){
	if(pointee_->parent_ == nullptr){
		pointee_ = nullptr;
		index_ = 0;
		return;
	}else{
		pointee_ = pointee_->parent_;
		for(index_ = 0; index_ < pointee_->usedSpace_;++index_){
			if (currElement()> element){
				return;
			}
		}
		moveUp(element);
	}
}

template<typename T> void
btree_iterator<T>::moveDown(){
	
	if(pointee_->children_[0] == nullptr) return;
	pointee_ = pointee_->children_[0];
	moveDown();
	return;
}



